import { originGrid } from "./grid.js";
import { updateLifeScore, updateScore } from "../interface/barreScore.js";
import VirtualNode from "../core/node.js";
// import { arrayOfGhost, intervalIDs } from "./avatar.js"
// import { gameOver, winner } from "../interface/menuPause.js"
// import { playSound } from "../interface/sound.js";

export let detonationID = 0;
export let argBombe = [];
let deathCounter = 0;
export class Bomb {
  constructor() {
    this.max = 100;
    this.delay = 2000; // en milliseconde
  }

  canCall = true;
  poserBomb(divs, position, actor) {
    if (!this.canCall) {
      // console.log("Trop tot boy");
      return;
    }

    if (this.max > 0) {
      const iconBomb = new VirtualNode({
        tag: "p",
        attrs: {
          class: "bomb",
          style: `font-size: 35px;`,
        },
        children: ["ðŸ’£"],
      })

      if (divs[position].innerHTML == "") {
        divs[position].appendChild(iconBomb.render());
      }
      argBombe = [divs, position];
      detonationID = setTimeout(() => {
        this.#exploserBomb(divs, position, actor);
        detonationID = 0;
        argBombe = [];
      }, this.delay);
      this.max--;
    } else {
      // gameOver(1, "Vous n'avez plus de bombe !!!")
    }
    /* Logique Debounce : est une technique utilisÃ©e pour limiter la
         frÃ©quence Ã  laquelle une fonction peut Ãªtre appelÃ©e  */
    this.canCall = false;
    setTimeout(() => {
      this.canCall = true;
    }, this.delay);
  }

  #exploserBomb(nodes, position, actor) {
    // On enleve d'abord la bombe
    nodes[position].removeChild(nodes[position].firstChild);

    // On recupere tous les avatars et leur position
    const allAvatar = nodes[0].querySelectorAll("img");
    let avatarPos = [];
    for (let i = 0; i < allAvatar.length; i++) {
      let xyAvatar = allAvatar[i].style.transform.match(/(-?\d+(?:\.\d+)?)/g);
      let xAvat = parseInt(xyAvatar[0]),
        yAvat = parseInt(xyAvatar[1]);
      avatarPos.push(((yAvat + 40) / 40) * 16 + xAvat / 40 - yAvat / 40 - 16);
    }

    // jouer le son de l'exposion
    // playSound("sound_bomb.mp3");

    // Cassage des murs etc
    this.#boom(nodes[position]);
    if (
      nodes[position + 1].className == "c" ||
      nodes[position + 1].className == "m"
    ) {
      this.#boom(nodes[position + 1]);
      originGrid[Math.floor((position + 1) / 15)][(position + 1) % 15] = "c";
    }
    if (
      nodes[position - 1].className == "c" ||
      nodes[position - 1].className == "m"
    ) {
      this.#boom(nodes[position - 1]);
      originGrid[Math.floor((position - 1) / 15)][(position - 1) % 15] = "c";
    }
    if (
      nodes[position - 15].className == "c" ||
      nodes[position - 15].className == "m"
    ) {
      // console.log(Math.floor((position - 15) / 15), (position - 15) % 15, originGrid[Math.floor((position - 15) / 15)][(position - 15) % 15]);
      originGrid[Math.floor((position - 15) / 15)][(position - 15) % 15] = "c";
      this.#boom(nodes[position - 15]);
    }
    if (
      nodes[position + 15].className == "c" ||
      nodes[position + 15].className == "m"
    ) {
      // console.log(Math.floor((position + 15) / 15), (position + 15) % 15, originGrid[Math.floor((position + 15) / 15)][(position + 15) % 15]);
      originGrid[Math.floor((position + 15) / 15)][(position + 15) % 15] = "c";
      this.#boom(nodes[position + 15]);
    }
    // On diminue la vie du joueur s'il se trouve dans le champ de portÃ©
    let actorPos = avatarPos[0]
    if (actorPos == position + 1 || actorPos == position - 1 || actorPos == position + 15 || actorPos == position - 15 || actorPos == position) {
        updateLifeScore(actor)
    }

    // On kill l'ennemi s'il est dans les parages, Ã  i=0 on a l'acteur
    // console.log('Avatar lenght', avatarPos);
    // for (let i = 1; i < avatarPos.length; i++) {
    //     if ((avatarPos[i] == position + 1 || avatarPos[i] == position - 1 || avatarPos[i] == position + 15 || avatarPos[i] == position - 15 || avatarPos[i] == position) && arrayOfGhost[i - 1].life != 0) {
    //         allAvatar[i].style.display = 'none'
    //         arrayOfGhost[i - 1].life = 0
    //         cancelAnimationFrame(intervalIDs[i - 1])
    //         deathCounter++
    //         console.log(deathCounter);
    //         if (deathCounter === arrayOfGhost.length ){
    //             winner()
    //         }
    //     }
    // }
  }

  #boom(node) {
    node.textContent = "ðŸ’¥";
    if (node.className === "m") updateScore();
    requestAnimationFrame(() => {
      this.#animateExplo(node, 25);
    });
  }

  #animateExplo(node, taille) {
    taille += 5;
    node.style.fontSize = `${taille}px`;
    if (taille < 45) {
      requestAnimationFrame(() => {
        this.#animateExplo(node, taille);
      });
    } else {
      node.className = "c";
      node.style.fontSize = "35px";
      if (node.dataset.powerUp == "bombe") {
        node.textContent = "ðŸ’£";
      } else {
        node.textContent = "";
      }
    }
  }
}
